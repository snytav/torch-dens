# -*- coding: utf-8 -*-
"""You can torch.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u9mI2Cy_8JxMjsF3rOGEQwYGDhhY5xkZ
"""

import autograd.numpy as np
import torch

# Simulation parameters
N         = 1       # Number of particles
Nx        = 10      # Number of mesh cells
t         = 0       # current time of the simulation
tEnd      = 50      # time at which simulation ends
dt        = 1       # timestep
boxsize   = 1.0      # periodic domain [0,boxsize]
n0        = 1       # electron number density
vb        = 3       # beam velocity
vth       = 1       # beam width
A         = 0.1     # perturbation
plotRealTime = True # switch on for plotting as the simulation goes along

# Generate Initial Conditions
#np.random.seed(42)            # set the random number generator seed
# construct 2 opposite-moving Guassian beams
#pos  = torch.rand(N) * boxsize
#X = np.array([[0.37454012], [0.95071431], [0.73199394], [0.59865848], [0.15601864], [0.15599452], [0.05808361], [0.86617615], [0.60111501], [0.70807258]]) #[[0.37454012], [0.95071431], [0.73199394], [0.59865848], [0.15601864], [0.15599452], [0.05808361], [0.86617615], [0.60111501], [0.70807258]])
#X = X.reshape(X.shape[0])
X = np.loadtxt('POS.Txt')
pos  = torch.from_numpy(X)
pos.requires_grad = True


xx = torch.linspace(0,boxsize,Nx)

import sys
def denst(Pos,Nx,boxsize,n0):
    N = Pos.shape[0]
    dx = boxsize/Nx
    n= torch.zeros(Nx)
    for pos in Pos:
        j = torch.floor(pos / dx).int()
        jp1 = j + 1
        weight_j=(jp1 * dx - pos) / dx
        weight_jp1 = (pos - j * dx) / dx
        jp1 = torch.remainder(jp1, Nx)
        n[j] += weight_j
        n[jp1] += weight_jp1

    n *= n0 * boxsize / N / dx
    return n


import matplotlib.pyplot as plt
fig = plt.figure()
plt.legend()
n0 = torch.exp(xx)
plt.plot(xx.numpy(),n0.detach().numpy(),color='green')
optimizer = torch.optim.Adam([pos],lr=0.001)
lf = 1e6*torch.ones(1)
i = 0
while lf.item() > 1e-2:
    optimizer.zero_grad()
    n = denst(pos,Nx,boxsize,n0)
    #plt.plot(xx.numpy(),n.detach().numpy(),color='red',label='iteration '+ str(i))
    n0 = torch.exp(xx) # torch.ones_like(n)
    lf = torch.max(torch.abs(torch.subtract(n,n0)))
    print(i,lf)
    lf.backward()
    optimizer.step()
    i = i+1
plt.scatter(xx.numpy(),n.detach().numpy(),color='blue',marker='o')
plt.show()
qq = 0




import matplotlib.pyplot as plt
# plt.plot(n)

